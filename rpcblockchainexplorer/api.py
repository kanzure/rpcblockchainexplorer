"""
Autogenerate API endpoints by inspecting python-bitcoinlib's RPC client because
maximum lazy.
"""

from copy import copy

# HACK: view_func is weird
import types

# For using python-bitcoinlib for details about the Bitcoin Core RPC protocol.
import inspect

# For some even more devious trickery involving partilaly-pre-specified
# function calls.
import functools

# Proxy class is used to get information about accepted parameters. Yeah,
# pretty lame but it works.
from bitcoin.rpc import Proxy

# because of the interwebs...
from flask import (
    Blueprint,
    request,
    g,
)

api = Blueprint("api", __name__, url_prefix="")

ALLOWED_COMMANDS = [
    # blockchain
    "getbestblockhash",
    "getblock",
    "getblockchaininfo",
    "getblockcount",
    "getblockhash",
    "getchaintips",
    "getdifficulty",
    "getmempoolinfo",
    "gettxout",

    # network
    "getconnectioncount",
    "getnettotals",
    "getnetworkinfo",
    "getpeerinfo",

    # transactions
    "getrawtransaction",
    "decoderawtransaction",
]

# All API endpoints conform to the following template, which can also be used
# to construct valid urls.
API_ENDPOINT_TEMPLATE = "/{command_name}"

def create_api_endpoints(commands=ALLOWED_COMMANDS):
    """
    Automatically generate all API endpoints by (ab)using python-bitcoinlib.
    """

    # Only generate API endpoints for the explicitly whitelisted commands.
    for command in commands:

        # store any additional arguments here
        keyword_arguments = {}

        if command in Proxy.__dict__.keys():
            # get a reference to the function
            rpcfunction = Proxy.__dict__[command]

            # investigate the function signature
            argument_spec = inspect.getargspec(rpcfunction)

            # only look at the arguments
            arguments = argument_spec.args

            # nobody cares about the self
            arguments.remove("self")

            # "self" is never a default value
            defaults = argument_spec.defaults

            # Preserve this information for later when constructing the API
            # endpoints.
            for (argument_index, argument) in enumerate(arguments):
                # Perhaps there are not always default values? Who knows.
                if defaults and len(defaults) > argument_index:
                    some_default = defaults[argument_index]
                else:
                    some_default = None

                keyword_arguments[argument] = some_default

        # Construct an API endpoint that accepts the computed arguments. Begin
        # by constructing the API endpoint uri from the template.

        # endpoint is always based on the command name
        api_uri = API_ENDPOINT_TEMPLATE.format(command_name=command)

        def some_command_endpoint():
            """
            Autogenerated API endpoint.
            """

            # Allow the defaults or user-passed values to be used.
            params = {}

            # Use request.args to get the user-passed value, otherwise use the
            # default as defined in python-bitcoinlib.
            for (argument_name, default_value) in keyword_arguments.items():
                params[argument_name] = request.args.get(argument_name, default_value)

            # Get a reference to the command, if any.
            if command in Proxy.__dict__.keys():
                callable_function = g.bitcoin_rpc_client.__dict__[command]
                rpc_function = functools.partial(callable_function)
            else:
                callable_function = g.bitcoin_rpc_client._call
                _self = g.bitcoin_rpc_client
                rpc_function = functools.partial(callable_function, command)

            # Call the RPC service command and pass in all of the given
            # parameters.
            results = rpc_function(**params)

            # That's all, folks.
            return repr(results)

        #temporary_function = types.FunctionType(
        #    # TODO: use func_name in python2
        #    copy(some_command_endpoint.__code__),
        #
        #    # use func_globals in python2
        #    copy(some_command_endpoint.__globals__),
        #
        #    name=command,
        #
        #    # use func_defaults in python2
        #    argdefs=copy(some_command_endpoint.__defaults__),
        #
        #    # use just "closure" in python2
        #    closure=copy(some_command_endpoint.__closure__),
        #)

        api.add_url_rule(api_uri, endpoint=command, view_func=some_command_endpoint, methods=["GET"])

# Always create all the endpoints when importing this module. This will attach
# the endpoints to the blueprint, which can then be attached to flask
# application instances.
create_api_endpoints()
